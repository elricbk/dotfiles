snippet inc "#include local header (inc)"
#include "${1:`!p snip.rv = snip.basename + '.h'`}"
endsnippet

snippet Inc "#include <> (Inc)"
#include <${1:.h}>
endsnippet

snippet main "main() (main)"
int main()
{
	${VISUAL}${0}
	return 0;
}
endsnippet

snippet s "std::string" w
std::string $0
endsnippet

snippet s? "boost::optional<std::string>" w
boost::optional<std::string> $0
endsnippet

snippet rcs "const std::string& " w
const std::string& $0
endsnippet

snippet rca "const auto& " w
const auto& $0
endsnippet

snippet rcV "const std::vector& " w
const std::vector<${1:T}>& $2
endsnippet

snippet V "vector" w
std::vector<${1:T}> $2
endsnippet

snippet S "set" w
std::set<${1:T}> $2
endsnippet

snippet Vs "vector of strings" w
std::vector<std::string> $0
endsnippet

snippet Vi "vector of int" w
std::vector<int> $0
endsnippet

snippet Mss "map" w
std::map<std::string, std::string> $0
endsnippet

snippet UMsi "map" w
std::unordered_map<std::string, int> $0
endsnippet

snippet USs "unordered_set<string>" w
std::unordered_set<std::string> $0
endsnippet

snippet fix "fixme" b
// FIXME(bkuchin): $0
endsnippet

snippet hack "hack" b
// HACK(bkuchin): $0
endsnippet

snippet o<< "operator <<()" b
static inline
std::ostream& operator<<(std::ostream& os, const $1& ${2:item})
{
	$3
	return os;
}
endsnippet

snippet o== "operator ==()" b
static inline
bool operator==(const $1& lhs, const $1& rhs)
{
	$2
}
endsnippet

snippet ca "const auto" w
const auto $0
endsnippet

snippet ns "namespace" w
namespace $0
endsnippet

snippet nsa "anonymous namespace" w
namespace {

${VISUAL}$0

} // namespace
endsnippet

snippet fori "Description" b
for (size_t i = 0; i < ${1:size}; ++i) {
	$2
}
endsnippet

snippet feca "for (const auto& item" b
for (const auto& ${1:item} : ${2:container}) {
	$3
}
endsnippet

snippet ts "BOOST_AUTO_TEST_SUITE" b
BOOST_AUTO_TEST_SUITE($1)

$2

BOOST_AUTO_TEST_SUITE_END()
endsnippet

snippet tsf "BOOST_FIXTURE_TEST_SUITE" b
BOOST_FIXTURE_TEST_SUITE($1)

$2

BOOST_AUTO_TEST_SUITE_END()
endsnippet

snippet tc "BOOST_AUTO_TEST_CASE" b
BOOST_AUTO_TEST_CASE($1)
{
	$2
}
endsnippet

snippet ld "logging debug" w
MAPS_DEBUG() << $1
endsnippet

snippet li "logging info" w
MAPS_INFO() << $1
endsnippet

snippet lw "logging warn" w
MAPS_WARN() << $1
endsnippet

snippet le "logging error" w
MAPS_ERROR() << $1
endsnippet

snippet lv "log value" w
"$1=" << $1 << $2
endsnippet

snippet lsv "log string value (with quotes)" w
"$1='" << $1 << "'"$2
endsnippet

snippet un "using namespace" b
using namespace $0
endsnippet

snippet z "size_t" w
size_t 
endsnippet

snippet UP "std::unique_ptr" w
std::unique_ptr<${0:${VISUAL}}>
endsnippet

snippet SP "std::shared_ptr" w
std::shared_ptr<${0:${VISUAL}}>
endsnippet

snippet MS "std::make_shared" w
std::make_shared<${0:${VISUAL}}>
endsnippet

snippet MU "std::make_unique" w
std::make_unique<${0:${VISUAL}}>
endsnippet

snippet M? "boost::make_optional" w
boost::make_optional<${0:${VISUAL}}>
endsnippet

snippet rcSP "const std::shared_ptr<>?" w
const std::shared_ptr<${0:${VISUAL}}>&
endsnippet

snippet sc "static_cast" w
static_cast<$0>(${VISUAL})
endsnippet

snippet dc "dynamic_cast" w
dynamic_cast<$0>(${VISUAL})
endsnippet

snippet rc "reinterpret_cast" w
reinterpret_cast<$0>(${VISUAL})
endsnippet

snippet cb "const bool" w
const bool $0
endsnippet

snippet rc? "const boost::optional<>&" w
const boost::optional<$1>& $0
endsnippet

snippet ? "boost::optional" w
boost::optional<$1> $0
endsnippet

snippet cs "const std::string" w
const std::string $0
endsnippet

snippet ifc "if (...) { continue; }" b
if ($0) { continue; }
endsnippet

snippet ifr "if (...) { return; }" b
if ($0) { return; }
endsnippet

snippet once "#pragma once" b
#pragma once
endsnippet

snippet pcc "const char*" w
const char* $0
endsnippet

snippet V8 "" w
std::vector<uint8_t>
endsnippet

snippet V16 "" w
std::vector<uint16_t>
endsnippet

snippet V32 "" w
std::vector<uint32_t>
endsnippet

snippet \ "basic lambda function" i
[] (auto&& it) { return $0; }
endsnippet

snippet \= "copy lambda function" i
[=] (auto&& it) { return $0; }
endsnippet

snippet \& "capture lambda function" i
[&] (auto&& it) { return $0; }
endsnippet

snippet mv "std::move" w
std::move(${VISUAL}$0)
endsnippet

